# 大模型象棋对战系统产品说明文档

## 1. 产品概述

### 1.1 产品名称
大模型象棋对战系统 (LLM Chess Battle System)

### 1.2 产品简介
本产品是一个基于大语言模型的象棋对战系统，支持两个不同的大模型（如OpenAI o3 vs DeepSeek）进行象棋对弈，提供文本化棋局描述和2D可视化棋盘展示。

### 1.3 产品定位
- 面向AI研究者和象棋爱好者
- 展示不同大模型的象棋博弈能力
- 提供简洁直观的对战观察平台

## 2. 核心功能

### 2.1 双模型对战引擎
- **支持的大模型**：
  - OpenAI GPT系列（GPT-4, o3等）
  - DeepSeek系列模型
  - Claude系列模型
  - 其他支持API调用的大模型

- **对战模式**：
  - 模型 vs 模型（主要功能）
  - 单局对战
  - 实时对战观察

### 2.2 文本化棋局描述

#### 2.2.1 标准象棋记谱法
```
红方（o3模型）：炮二平五  马二进三  车一平二
黑方（DeepSeek）：马8进7   炮8平5   车9平8
```

#### 2.2.2 模型思考过程
```
第3回合：
o3模型思考：当前局面需要控制中路，选择炮二平五占据要点
DeepSeek思考：对方中炮开局，我方应该马8进7应对，保持平衡
当前评估：双方开局正常，暂无明显优劣
```

### 2.3 2D棋盘可视化
- **棋盘界面**：
  - 传统中式象棋棋盘布局
  - 清晰的棋子显示
  - 最后一步高亮显示
  - 模型名称标识

- **实时更新**：
  - 棋子移动动画
  - 回合计数显示
  - 用时统计
  - 胜负判定

## 3. 技术架构

### 3.1 系统架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Web前端界面   │◄──►│   Python后端    │◄──►│   大模型API     │
│  - 2D棋盘显示   │    │  - 象棋规则引擎 │    │  - OpenAI API   │
│  - 实时更新     │    │  - 对战管理     │    │  - DeepSeek API │
│  - 用户交互     │    │  - 文本处理     │    │  - 其他模型API  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 3.2 技术栈
- **后端**：Python 3.8+
- **Web框架**：Flask/FastAPI
- **前端**：HTML + CSS + JavaScript
- **象棋引擎**：python-chess库
- **API调用**：requests/httpx
- **界面渲染**：Canvas/SVG

## 4. 核心模块设计

### 4.1 象棋引擎模块
```python
import chess
import chess.engine

class ChessGame:
    def __init__(self):
        self.board = chess.Board()
        self.move_history = []
        self.current_player = "red"
    
    def make_move(self, move_str):
        """执行棋步"""
        try:
            move = chess.Move.from_uci(move_str)
            if move in self.board.legal_moves:
                self.board.push(move)
                self.move_history.append(move_str)
                self.switch_player()
                return True
        except:
            return False
    
    def get_board_state(self):
        """获取当前棋盘状态"""
        return self.board.fen()
    
    def is_game_over(self):
        """判断游戏是否结束"""
        return self.board.is_game_over()
```

### 4.2 大模型接口模块
```python
import openai
import requests

class LLMPlayer:
    def __init__(self, model_name, api_key, base_url=None):
        self.model_name = model_name
        self.api_key = api_key
        self.base_url = base_url
    
    def get_move(self, board_state, move_history):
        """获取模型的下一步棋"""
        prompt = self.build_chess_prompt(board_state, move_history)
        
        if "openai" in self.model_name.lower():
            return self.call_openai_api(prompt)
        elif "deepseek" in self.model_name.lower():
            return self.call_deepseek_api(prompt)
    
    def build_chess_prompt(self, board_state, move_history):
        """构建象棋提示词"""
        return f"""
        你是一个象棋高手，请根据当前棋局选择最佳的下一步棋。
        
        当前棋盘状态：{board_state}
        历史棋谱：{move_history}
        
        请返回你的下一步棋，格式为标准象棋记谱法（如：炮二平五）
        """
    
    def call_openai_api(self, prompt):
        """调用OpenAI API"""
        client = openai.OpenAI(api_key=self.api_key)
        response = client.chat.completions.create(
            model=self.model_name,
            messages=[{"role": "user", "content": prompt}]
        )
        return response.choices[0].message.content
    
    def call_deepseek_api(self, prompt):
        """调用DeepSeek API"""
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model_name,
            "messages": [{"role": "user", "content": prompt}]
        }
        response = requests.post(
            f"{self.base_url}/chat/completions",
            headers=headers,
            json=data
        )
        return response.json()["choices"][0]["message"]["content"]
```

### 4.3 对战管理模块
```python
class ChessBattle:
    def __init__(self, red_player, black_player):
        self.game = ChessGame()
        self.red_player = red_player  # LLMPlayer实例
        self.black_player = black_player  # LLMPlayer实例
        self.battle_log = []
    
    def start_battle(self):
        """开始对战"""
        while not self.game.is_game_over():
            current_player = self.red_player if self.game.current_player == "red" else self.black_player
            
            # 获取模型的下一步棋
            move = current_player.get_move(
                self.game.get_board_state(),
                self.game.move_history
            )
            
            # 执行棋步
            if self.game.make_move(move):
                self.log_move(current_player.model_name, move)
            else:
                print(f"无效棋步：{move}")
                break
        
        return self.get_battle_result()
    
    def log_move(self, player_name, move):
        """记录棋步"""
        self.battle_log.append({
            "player": player_name,
            "move": move,
            "board_state": self.game.get_board_state(),
            "timestamp": time.time()
        })
    
    def get_battle_result(self):
        """获取对战结果"""
        if self.game.board.is_checkmate():
            winner = "黑方" if self.game.current_player == "red" else "红方"
            return f"{winner}获胜（将死）"
        elif self.game.board.is_stalemate():
            return "平局（逼和）"
        else:
            return "对局进行中"
```

## 5. 用户界面设计

### 5.1 主界面布局
```
┌─────────────────────────────────────────────────────────────┐
│                    大模型象棋对战系统                       │
├─────────────────┬─────────────────────┬─────────────────────┤
│                 │                     │                     │
│   模型设置面板  │      象棋棋盘       │    对战信息面板     │
│                 │                     │                     │
│  红方：o3       │   ┌─────────────┐   │  当前回合：第5回合  │
│  黑方：DeepSeek │   │             │   │  红方用时：02:15    │
│                 │   │   2D棋盘    │   │  黑方用时：01:58    │
│  [开始对战]     │   │    显示     │   │  当前状态：进行中   │
│  [重新开始]     │   │             │   │                     │
│  [暂停对战]     │   └─────────────┘   │  最后一步：         │
│                 │                     │  炮二平五           │
├─────────────────┼─────────────────────┼─────────────────────┤
│                 │                     │                     │
│   完整棋谱      │    模型思考过程     │    对战统计         │
│                 │                     │                     │
│  1. 炮二平五    │  o3：分析当前局面   │  总对局：3场        │
│  2. 马8进7      │  需要控制中路...    │  o3胜：2场          │
│  3. 马二进三    │                     │  DeepSeek胜：1场    │
│  4. 炮8平5      │  DeepSeek：对方中炮 │  平局：0场          │
│  ...            │  我方马8进7应对...  │                     │
│                 │                     │                     │
└─────────────────┴─────────────────────┴─────────────────────┘
```

### 5.2 2D棋盘实现
```javascript
class ChessBoardRenderer {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.boardSize = 400;
        this.cellSize = this.boardSize / 9;
    }
    
    drawBoard() {
        // 绘制棋盘线条
        this.ctx.strokeStyle = '#8B4513';
        this.ctx.lineWidth = 2;
        
        // 横线
        for (let i = 0; i <= 9; i++) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, i * this.cellSize);
            this.ctx.lineTo(this.boardSize, i * this.cellSize);
            this.ctx.stroke();
        }
        
        // 竖线
        for (let i = 0; i <= 8; i++) {
            this.ctx.beginPath();
            this.ctx.moveTo(i * this.cellSize, 0);
            this.ctx.lineTo(i * this.cellSize, this.boardSize);
            this.ctx.stroke();
        }
    }
    
    drawPiece(x, y, piece, isRed) {
        const centerX = x * this.cellSize;
        const centerY = y * this.cellSize;
        const radius = this.cellSize * 0.4;
        
        // 绘制棋子圆形
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        this.ctx.fillStyle = isRed ? '#FF6B6B' : '#4ECDC4';
        this.ctx.fill();
        this.ctx.strokeStyle = '#333';
        this.ctx.stroke();
        
        // 绘制棋子文字
        this.ctx.fillStyle = '#333';
        this.ctx.font = '20px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(piece, centerX, centerY + 7);
    }
    
    highlightLastMove(fromX, fromY, toX, toY) {
        // 高亮最后一步棋的起点和终点
        this.ctx.strokeStyle = '#FFD700';
        this.ctx.lineWidth = 3;
        this.ctx.strokeRect(fromX * this.cellSize - 15, fromY * this.cellSize - 15, 30, 30);
        this.ctx.strokeRect(toX * this.cellSize - 15, toY * this.cellSize - 15, 30, 30);
    }
}
```

## 6. 数据格式

### 6.1 对战配置
```json
{
  "battle_config": {
    "red_player": {
      "model_name": "gpt-4",
      "api_key": "sk-xxx",
      "display_name": "OpenAI o3"
    },
    "black_player": {
      "model_name": "deepseek-chat",
      "api_key": "sk-xxx",
      "base_url": "https://api.deepseek.com/v1",
      "display_name": "DeepSeek"
    },
    "time_limit": 300,
    "max_moves": 200
  }
}
```

### 6.2 对战记录
```json
{
  "battle_id": "battle_20240807_001",
  "timestamp": "2024-08-07T16:00:00Z",
  "players": {
    "red": "OpenAI o3",
    "black": "DeepSeek"
  },
  "moves": [
    {
      "round": 1,
      "player": "red",
      "move": "炮二平五",
      "thinking": "控制中路要点，开局占据优势",
      "time_used": 3.2,
      "board_state": "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR"
    }
  ],
  "result": {
    "winner": "red",
    "reason": "checkmate",
    "total_moves": 45,
    "duration": "00:15:23"
  }
}
```

## 7. 部署说明

### 7.1 环境要求
```bash
# Python版本
Python 3.8+

# 依赖包
pip install flask
pip install python-chess
pip install openai
pip install requests
pip install python-dotenv
```

### 7.2 项目结构
```
chess-llm-battle/
├── app.py              # 主应用文件
├── models/
│   ├── chess_game.py   # 象棋游戏逻辑
│   ├── llm_player.py   # 大模型玩家
│   └── battle.py       # 对战管理
├── static/
│   ├── css/
│   │   └── style.css   # 样式文件
│   └── js/
│       └── chess.js    # 前端JavaScript
├── templates/
│   └── index.html      # 主页面模板
├── config.py           # 配置文件
└── requirements.txt    # 依赖列表
```

### 7.3 启动方式
```bash
# 克隆项目
git clone https://github.com/chess-llm-battle.git
cd chess-llm-battle

# 安装依赖
pip install -r requirements.txt

# 配置API密钥
cp .env.example .env
# 编辑.env文件，填入API密钥

# 启动应用
python app.py

# 访问系统
http://localhost:5000
```

## 8. 使用说明

### 8.1 基本操作
1. 打开系统主页面
2. 在左侧面板选择红方和黑方的大模型
3. 点击"开始对战"按钮
4. 观察2D棋盘上的实时对战过程
5. 查看右侧的对战信息和模型思考过程

### 8.2 功能特点
- **自动对战**：两个模型自动进行象棋对弈
- **实时显示**：棋盘状态实时更新
- **思考过程**：显示模型的思考和决策过程
- **完整记录**：保存完整的对战棋谱
- **简洁界面**：专注于对战观察体验

## 9. 扩展计划

### 9.1 短期优化
- [ ] 增加更多大模型支持
- [ ] 优化模型提示词
- [ ] 添加对战回放功能
- [ ] 改进界面交互体验

### 9.2 长期规划
- [ ] 支持批量对战测试
- [ ] 添加模型性能分析
- [ ] 实现对战直播功能
- [ ] 开发移动端版本

## 10. 总结

大模型象棋对战系统是一个专注于展示不同大语言模型象棋博弈能力的简洁平台。通过纯Python技术栈和2D界面设计，为用户提供直观的模型对战观察体验。系统架构简单清晰，易于部署和维护，是研究大模型博弈能力的理想工具。

---

**文档版本**：v2.0  
**最后更新**：2024年8月7日  
**技术栈**：纯Python + 2D界面  
**主要功能**：o3 vs DeepSeek 象棋对战